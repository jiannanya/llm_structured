// Generated by test5.test1.tools.generate_typescript_defs
// Source of truth: test5/test1/python/llm_structured.py (thin wrapper) + C++ core
//
// This file intentionally focuses on TYPES (not runtime validation).

export type Json = null | boolean | number | string | Json[] | { [key: string]: Json };

export interface ValidationError {
  kind?: 'schema' | 'type' | 'limit' | 'parse';
  message: string;
  path: string; // e.g. $.items[0].id
  jsonPointer?: string; // e.g. /items/0/id
  limit?: { kind: 'maxBufferBytes' | 'maxItems'; current: number; max: number };
}

export type JsonSchema = {
  type?: 'object' | 'array' | 'string' | 'number' | 'integer' | 'boolean' | 'null';
  enum?: Json[];
  const?: Json;
  allOf?: JsonSchema[];
  anyOf?: JsonSchema[];
  oneOf?: JsonSchema[];
  if?: JsonSchema;
  then?: JsonSchema;
  else?: JsonSchema;
  dependentRequired?: Record<string, string[]>;
  properties?: Record<string, JsonSchema>;
  required?: string[];
  default?: Json;
  additionalProperties?: boolean | JsonSchema;
  propertyNames?: JsonSchema;
  items?: JsonSchema;
  minItems?: number;
  maxItems?: number;
  contains?: JsonSchema;
  minContains?: number;
  maxContains?: number;
  minLength?: number;
  maxLength?: number;
  pattern?: string;
  format?: 'email' | 'uuid' | 'date-time' | (string & {});
  minimum?: number;
  maximum?: number;
  multipleOf?: number;
  minProperties?: number;
  maxProperties?: number;
};

export interface MarkdownValidationSchema {
  requiredHeadings?: string[];
  forbidHtml?: boolean;
  maxLineLength?: number;
  minCodeBlocks?: number;
  maxCodeBlocks?: number;
  requiredCodeFences?: string[];
  minTables?: number;
  requireTaskList?: boolean;
  sections?: Record<string, {
    minLength?: number;
    maxLength?: number;
    requireBullets?: boolean;
    minBullets?: number;
    maxBullets?: number;
  }>;
}

export interface MarkdownParsed {
  text: string;
  lines: string[];
  headings: Array<{ level: number; title: string; line: number }>;
  sections: Record<string, string[]>;
  codeBlocks: Array<{ lang: string; body: string }>;
  bulletLineNumbers: number[];
  taskLineNumbers: number[];
  tables: Array<{ startLine: number; raw: string }>;
}

export interface KeyValueSchema {
  required?: string[];
  allowExtra?: boolean;
  patterns?: Record<string, string>; // key -> regex
  enum?: Record<string, string[]>;
}

export interface SqlValidationSchema {
  allowedStatements?: string[];
  forbidKeywords?: string[];
  forbidComments?: boolean;
  forbidSemicolon?: boolean;
  requireFrom?: boolean;
  requireWhere?: boolean;
  requireLimit?: boolean;
  maxLimit?: number;
  forbidUnion?: boolean;
  forbidSubqueries?: boolean;
  allowedTables?: string[];
  forbidSelectStar?: boolean;
  requireWhereColumns?: string[];
  forbidSchemas?: string[];
  forbidCrossJoin?: boolean;
  forbidSelectWithoutLimit?: boolean;
  requireOrderBy?: boolean;
  requireWherePatterns?: string[];
  forbidTables?: string[];

  // Hardened SQL safety options.
  maxJoins?: number;
  allowedJoinTypes?: string[];
  forbidOrTrue?: boolean;
  placeholderStyle?: 'qmark' | 'dollar' | 'either';
  forbidFunctions?: boolean | string[];
  allowedColumns?: string[];
  allowUnqualifiedColumns?: boolean;
}

export interface SqlParsed {
  sql: string;
  statementType: string;
  hasWhere: boolean;
  hasFrom: boolean;
  hasLimit: boolean;
  limit: number | null;
  hasUnion: boolean;
  hasComments: boolean;
  hasSubquery: boolean;
  tables: string[];
}

// ---- Convenience: example schema to type
// You can generate your own types using `schema_to_ts` in Python.

export type ExamplePlan = {
  title: string;
  steps:
  Array<
    {
      id: number;
      text: string;
    }
  >;
};

// ---- XML / HTML types ----

export type XmlNodeType = 'element' | 'text' | 'comment' | 'cdata' | 'processing_instruction' | 'doctype';

export interface XmlNode {
  type: XmlNodeType;
  name: string;
  text: string;
  attributes: Record<string, string>;
  children: XmlNode[];
}

export interface XmlRepairConfig {
  html_mode?: boolean;
  fix_unquoted_attributes?: boolean;
  auto_close_tags?: boolean;
  normalize_whitespace?: boolean;
  lowercase_names?: boolean;
  decode_entities?: boolean;
}

export interface XmlRepairMetadata {
  auto_closed_tags: number;
  fixed_attributes: number;
  decoded_entities: number;
  normalized_whitespace: number;
}

export interface XmlParseResult {
  ok: boolean;
  error: string;
  root: XmlNode | null;
}

export interface XmlParseResultEx {
  ok: boolean;
  error: string;
  root: XmlNode | null;
  metadata: XmlRepairMetadata;
}

export interface XmlValidationError {
  path: string;
  message: string;
}

export interface XmlValidationResult {
  ok: boolean;
  errors: XmlValidationError[];
}

export interface XmlParseAndValidateResult {
  ok: boolean;
  error: string;
  root: XmlNode | null;
  validation_errors: XmlValidationError[];
}

export interface XmlParseAndValidateResultEx {
  ok: boolean;
  error: string;
  root: XmlNode | null;
  validation_errors: XmlValidationError[];
  metadata: XmlRepairMetadata;
}

export interface XmlSchema {
  element?: string;
  requiredAttributes?: string[];
  attributes?: Record<string, {
    pattern?: string;
    enum?: string[];
  }>;
  children?: {
    minItems?: number;
    maxItems?: number;
    required?: string[];
  };
  childSchema?: Record<string, XmlSchema>;
}

// ---- Schema Inference types ----

export interface SchemaInferenceConfig {
  /** Include "examples" array with sample values (up to maxExamples) */
  includeExamples?: boolean;
  /** Maximum number of examples to include (default: 3) */
  maxExamples?: number;
  /** Include "default" from the first seen value */
  includeDefault?: boolean;
  /** Infer "format" for strings (e.g., "date-time", "email", "uri") */
  inferFormats?: boolean;
  /** Infer "pattern" for strings that look like specific formats */
  inferPatterns?: boolean;
  /** Infer numeric constraints (minimum, maximum) from seen values */
  inferNumericRanges?: boolean;
  /** Infer string constraints (minLength, maxLength) from seen values */
  inferStringLengths?: boolean;
  /** Infer array constraints (minItems, maxItems) from seen values */
  inferArrayLengths?: boolean;
  /** Make all object properties required by default (default: true) */
  requiredByDefault?: boolean;
  /** Set additionalProperties to false by default (default: true) */
  strictAdditionalProperties?: boolean;
  /** Prefer "integer" over "number" when all values are whole numbers (default: true) */
  preferInteger?: boolean;
  /** Merge multiple types into anyOf when values have different types (default: true) */
  allowAnyOf?: boolean;
  /** Include "description" placeholders for properties */
  includeDescriptions?: boolean;
  /** Detect enum values when all values are from a small set of strings (default: true) */
  detectEnums?: boolean;
  /** Max distinct values for enum detection (default: 10) */
  maxEnumValues?: number;
}

/** Infer JSON Schema from a single value */
export function inferSchema(value: Json, config?: SchemaInferenceConfig): JsonSchema;

/** Infer JSON Schema from multiple values (merges schemas) */
export function inferSchemaFromValues(values: Json[], config?: SchemaInferenceConfig): JsonSchema;

/** Merge two JSON Schemas into one that accepts values valid for either */
export function mergeSchemas(schema1: JsonSchema, schema2: JsonSchema, config?: SchemaInferenceConfig): JsonSchema;
